name: Convert Hosts Files

on:
  schedule:
    - cron: '0 7,15 * * *'   # æ¯å¤©åŒ—äº¬æ—¶é—´ 15:00 23:00 æ‰§è¡Œ
  workflow_dispatch:        # æ”¯æŒæ‰‹åŠ¨è¿è¡Œ

jobs:
  convert:
    runs-on: ubuntu-latest
    steps:
      - name: æ£€å‡ºä»“åº“
        uses: actions/checkout@v4

      - name: è®¾ç½® SSH å¯†é’¥
        uses: webfactory/ssh-agent@v0.5.1
        with:
          ssh-private-key: ${{ secrets.ACTIONS_DEPLOY_KEY }}

      - name: é…ç½® Git ç”¨æˆ·ä¿¡æ¯
        run: |
          git config --global user.name "${{ github.actor }}"
          git config --global user.email "${{ github.actor }}@users.noreply.github.com"
          # æ³¨æ„ï¼šä¸‹é¢è¿™è¡Œä¼šæŠŠ origin æŒ‡å‘å¦ä¸€ä¸ªä»“åº“ï¼ˆä¿æŒä½ åŸæ¥çš„é…ç½®ï¼‰
          git remote set-url origin git@github.com:Mercury000/covert-adhost.git
          git fetch

      - name: ä¸‹è½½ reward.txt
        run: |
          curl -fsSL -o reward.txt https://edge.microsoft.com/abusiveadblocking/api/v1/blocklist || true
          # è‹¥éœ€è¦ä¸‹è½½ all.txtï¼Œè¯·é€šè¿‡è®¾ç½®ä»“åº“ secret ALL_SOURCE æˆ–åœ¨æ­¤å¤„æ·»åŠ å®é™… URL
          if [ -n "${{ secrets.ALL_SOURCE }}" ]; then
            curl -fsSL -o all.txt "${{ secrets.ALL_SOURCE }}" || true
          fi

      - name: ç”Ÿæˆå½“å‰æ–‡ä»¶çš„ MD5 å€¼ï¼ˆå®¹é”™ï¼‰
        id: generate_md5
        run: |
          CURRENT_REWARD_MD5=""
          CURRENT_ALL_MD5=""
          if [ -f reward.txt ]; then
            CURRENT_REWARD_MD5=$(md5sum reward.txt | awk '{print $1}')
          fi
          if [ -f all.txt ]; then
            CURRENT_ALL_MD5=$(md5sum all.txt | awk '{print $1}')
          fi
          echo "CURRENT_REWARD_MD5=$CURRENT_REWARD_MD5" >> $GITHUB_ENV
          echo "CURRENT_ALL_MD5=$CURRENT_ALL_MD5" >> $GITHUB_ENV

      - name: åŠ è½½æˆ–åˆ›å»º md5_hashes.txtï¼ˆä½¿ç”¨ STORED_ å‰ç¼€ï¼‰
        id: load_or_create_md5
        run: |
          if [ -f md5_hashes.txt ]; then
            # md5_hashes.txt åº”åŒ…å« STORED_REWARD_MD5=... å’Œ STORED_ALL_MD5=...
            source md5_hashes.txt || true
            # å¯¼å‡ºä¸º PREVIOUS_* ä¾›åç»­æ¯”è¾ƒ
            echo "PREVIOUS_REWARD_MD5=${STORED_REWARD_MD5:-}" >> $GITHUB_ENV
            echo "PREVIOUS_ALL_MD5=${STORED_ALL_MD5:-}" >> $GITHUB_ENV
            echo "âœ… å·²åŠ è½½ä¸Šä¸€æ¬¡ä¿å­˜çš„ MD5 å€¼ã€‚"
          else
            echo "âš ï¸ æœªæ‰¾åˆ° md5_hashes.txtï¼Œæ­£åœ¨åˆ›å»ºæ–°çš„å“ˆå¸Œè®°å½•æ–‡ä»¶..."
            # ä½¿ç”¨ CURRENT_* åˆå§‹åŒ– STORED_*
            echo "STORED_REWARD_MD5=${CURRENT_REWARD_MD5:-}" > md5_hashes.txt
            echo "STORED_ALL_MD5=${CURRENT_ALL_MD5:-}" >> md5_hashes.txt
            echo "PREVIOUS_REWARD_MD5=${CURRENT_REWARD_MD5:-}" >> $GITHUB_ENV
            echo "PREVIOUS_ALL_MD5=${CURRENT_ALL_MD5:-}" >> $GITHUB_ENV
            echo "NEED_UPDATE=true" >> $GITHUB_ENV
            echo "ğŸ†• é¦–æ¬¡è¿è¡Œï¼šå·²ä¿å­˜åˆå§‹ MD5 å€¼åˆ° md5_hashes.txt"
          fi

      - name: åˆ¤æ–­æ˜¯å¦éœ€è¦æ›´æ–°
        id: check_update
        run: |
          NEED_UPDATE=false
          # è¯»å–å½“å‰å€¼ï¼ˆæ¥è‡ª generate_md5ï¼‰
          CURRENT_REWARD_MD5="${CURRENT_REWARD_MD5:-}"
          CURRENT_ALL_MD5="${CURRENT_ALL_MD5:-}"
          PREVIOUS_REWARD_MD5="${PREVIOUS_REWARD_MD5:-}"
          PREVIOUS_ALL_MD5="${PREVIOUS_ALL_MD5:-}"
          if [ -z "$PREVIOUS_REWARD_MD5" ] || [ "$CURRENT_REWARD_MD5" != "$PREVIOUS_REWARD_MD5" ] || [ "$CURRENT_ALL_MD5" != "$PREVIOUS_ALL_MD5" ]; then
            echo "ğŸ”„ æ£€æµ‹åˆ° reward.txt æˆ– all.txt å†…å®¹å‘ç”Ÿå˜åŒ–ï¼Œå‡†å¤‡æ‰§è¡Œè½¬æ¢ä»»åŠ¡ã€‚"
            NEED_UPDATE=true
          else
            echo "âœ… æ–‡ä»¶è‡ªä¸Šæ¬¡è¿è¡Œä»¥æ¥æœªå‘ç”Ÿå˜åŒ–ï¼Œè·³è¿‡åç»­å¤„ç†ã€‚"
            exit 0
          fi
          echo "NEED_UPDATE=$NEED_UPDATE" >> $GITHUB_ENV

      - name: æ›´æ–°å¹¶ä¿å­˜å½“å‰ MD5 å€¼
        if: env.NEED_UPDATE == 'true'
        run: |
          echo "ğŸ’¾ æ­£åœ¨æ›´æ–° md5_hashes.txt æ–‡ä»¶ä¸­çš„ MD5 å€¼..."
          echo "STORED_REWARD_MD5=${CURRENT_REWARD_MD5:-}" > md5_hashes.txt
          echo "STORED_ALL_MD5=${CURRENT_ALL_MD5:-}" >> md5_hashes.txt
          cat md5_hashes.txt

      - name: ç»Ÿä¸€è½¬æ¢ hosts æ–‡ä»¶ä¸º YAML æ ¼å¼
        if: env.NEED_UPDATE == 'true'
        run: |
          process_file() {
            input="$1"
            output="${input%.txt}.yaml"
            awk '
            BEGIN { c=1; u="" }
            /^#è‡ªå®šä¹‰é‡å®šå‘hosts/,/^#END/ { next }
            /^#æ›´æ–°æ—¶é—´:/ { u=$0; next }
            /^#/ { next }
            /^[[:space:]]*$/ { next }
            $1 == "0.0.0.0" && NF > 1 {
              if (c) {
                print "#Mercury\n#10007";
                if (u != "") print u;
                print "payload:";
                c=0;
              }
              if ($2 ~ /^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$/) {
                print "- IP-CIDR," $2 "/32"
              } else {
                print "- DOMAIN," $2
              }
            }' "$input" > "$output"
          }

          # ä»…åœ¨æ–‡ä»¶å­˜åœ¨æ—¶å¤„ç†
          if [ -f reward.txt ]; then process_file "reward.txt"; fi
          if [ -f all.txt ]; then process_file "all.txt"; fi

      - name: æ·»åŠ å¹¶å†™å…¥æå–è„šæœ¬ (Bash + Python)
        if: env.NEED_UPDATE == 'true'
        run: |
          # å†™å…¥ Bash è„šæœ¬
          cat > extract_domains.sh <<'EOF'
          #!/usr/bin/env bash
          # æå–åŸŸåè„šæœ¬ï¼ˆé€šç”¨ï¼Œæ”¯æŒ hosts / adblock / plain domain / URL æ ¼å¼ï¼‰
          # Usage: ./extract_domains.sh [INPUT_FILE] [OUTFILE]
          set -euo pipefail
          INPUT="${1:-reward.txt}"
          OUT="${2:-domains.txt}"
          TMP="$(mktemp)"
          trap 'rm -f "$TMP"' EXIT
          if [ ! -f "$INPUT" ]; then
            echo "è¾“å…¥æ–‡ä»¶ $INPUT ä¸å­˜åœ¨ï¼Œé€€å‡º"
            exit 0
          fi
          cp "$INPUT" "$TMP"
          awk '
          function trim(s) { sub(/^[ \t\r\n]+/, "", s); sub(/[ \t\r\n]+$/, "", s); return s }
          {
            line = $0
            sub(/#.*/,"",line)
            line = trim(line)
            if (line == "") next
            n = split(line, F, /[ \t]+/)
            token = F[1]
            if (token ~ /^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$/ || token == "127.0.0.1" || token == "::1") {
              if (n >= 2) token = F[2]; else next
            }
            gsub(/^\|\|/,"",token)
            gsub(/^\|/,"",token)
            gsub(/^https?:\/\//,"",token)
            sub(/:([0-9]+)($|\/)/, "", token)
            sub(/\/.*$/,"",token)
            sub(/\^.*$/,"",token)
            gsub(/^[ \t]+|[ \t]+$/,"",token)
            sub(/^[.]+/,"",token)
            gsub(/^[^A-Za-z0-9]+/, "", token)
            gsub(/[^A-Za-z0-9.-]+$/, "", token)
            if (token == "") next
            if (token ~ /^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$/) next
            if (tolower(token) == "localhost") next
            sub(/^www\./, "", token)
            print tolower(token)
          }
          ' "$TMP" | sort -u > "$OUT"
          echo "Wrote $(wc -l < "$OUT") unique domains to $OUT"
          EOF
          chmod +x extract_domains.sh

          # å†™å…¥ Python è„šæœ¬
          cat > extract_domains.py <<'EOF'
          #!/usr/bin/env python3
          """
          æå–åŸŸåè„šæœ¬ï¼ˆPython ç‰ˆæœ¬ï¼‰
          Usage: python3 extract_domains.py [INPUT_FILE] [OUTFILE]
          é»˜è®¤ INPUT_FILE: reward.txt
          """
          import sys, re, ipaddress
          INPUT = sys.argv[1] if len(sys.argv) > 1 else "reward.txt"
          OUT = sys.argv[2] if len(sys.argv) > 2 else "domains_py.txt"
          try:
              with open(INPUT, "r", encoding="utf-8", errors="ignore") as fh:
                  data = fh.read()
          except FileNotFoundError:
              print(f"è¾“å…¥æ–‡ä»¶ {INPUT} ä¸å­˜åœ¨ï¼Œé€€å‡º")
              sys.exit(0)
          domains = set()
          domain_re = re.compile(r'^[a-z0-9.-]+$')
          for raw in data.splitlines():
              line = raw.split('#', 1)[0].strip()
              if not line:
                  continue
              parts = re.split(r'\s+', line)
              token = parts[0]
              if len(parts) >= 2 and re.match(r'^\d+\.\d+\.\d+\.\d+$', parts[0]):
                  token = parts[1]
              token = re.sub(r'^\|\|', '', token)
              token = re.sub(r'^\|', '', token)
              token = re.sub(r'^https?://', '', token)
              token = re.sub(r':\d+($|/).*', '', token)
              token = re.sub(r'/.*$', '', token)
              token = re.sub(r'\^.*$', '', token)
              token = token.lstrip('.').strip()
              if not token:
                  continue
              try:
                  ipaddress.ip_address(token)
                  continue
              except Exception:
                  pass
              if token.lower() == "localhost":
                  continue
              token = re.sub(r'^www\.', '', token, flags=re.IGNORECASE)
              token = token.lower()
              if domain_re.match(token) and not token.startswith('-') and not token.endswith('-') and '..' not in token:
                  domains.add(token)
          with open(OUT, 'w') as f:
              for d in sorted(domains):
                  f.write(d + '\\n')
          print(f"Wrote {len(domains)} unique domains to {OUT}")
          EOF
          chmod +x extract_domains.py

      - name: æ‰§è¡Œæå–è„šæœ¬å¹¶ç”Ÿæˆ domains.txt
        if: env.NEED_UPDATE == 'true'
        run: |
          # ä½¿ç”¨ Bash è„šæœ¬ç”Ÿæˆ domains.txtï¼ˆä¸»è¾“å‡ºï¼‰
          ./extract_domains.sh reward.txt domains.txt || true
          # å¯é€‰ä½¿ç”¨ Python ç”Ÿæˆä¸€ä¸ªå¹¶è¡Œçš„æ–‡ä»¶ä»¥ä¾¿äº¤å‰æ£€æŸ¥ï¼ˆä¸é˜»å¡æ•´ä¸ªæµç¨‹ï¼‰
          python3 extract_domains.py reward.txt domains_py.txt || true
          echo "domains.txt Preview:"
          head -n 50 domains.txt || true

      - name: æäº¤å¹¶æ¨é€æ›´æ”¹
        if: env.NEED_UPDATE == 'true'
        uses: stefanzweifel/git-auto-commit-action@v4
        with:
          file_pattern: "*.yaml md5_hashes.txt domains.txt extract_domains.sh extract_domains.py"
          commit_message: æ›´æ–°è¿œç¨‹ hosts æ–‡ä»¶ç”Ÿæˆçš„ YAMLã€MD5 å“ˆå¸Œå€¼ä»¥åŠ domains.txt
